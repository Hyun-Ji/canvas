var fs = require('vinyl-fs');
var debug = require('debug')('umi:src');
var join = require('path').join;
var dirname = require('path').dirname;
var extname = require('path').extname;

module.exports = function src(file, options) {
  options = updateOptions(options);
  var files = getFiles(file, options);
  file = join(options.pkg.dest, file);
  debug('%s deps %s', file, files);
  return fs.src([file].concat(files), options);
};

function getFiles(file, options) {
  var pkg = options.pkg, include = options.include;

  switch(include) {
    case 'self':
      return getSelf(file, pkg);
    case 'all':
      return getAll(file, pkg);
    default:
      return getRelative(file, pkg);
  }
}

function getAll(file, pkg) {
  var files = [], deps = pkg.dependencies;
  pkg.files[file].dependencies
    .forEach(function(name) {
      if (/^\./.test(name)) {
        var fileTmp = join(dirname(file), name);
        files.push(resolve(fileTmp, pkg));
      } else {
        var p = deps[name];
        if (p) {
          files.push(join(p.dest, p.main));
          if (!/\.css$/.test(p.main)) {
            files = files.concat(getAll(p.main, p));
          }
        }
      }
    });
  return files.filter(function(item, index, arr) {
    return index === arr.indexOf(item);
  });
}

function getRelative(file, pkg) {
  var files = [], deps = pkg.dependencies;
  pkg.files[file].dependencies
    .forEach(function(name) {
      if (name.charAt(0) === '.') {
        var fileTmp = join(dirname(file), name);
        files.push(resolve(fileTmp, pkg));
      } else {
        var p = deps[name];
        if (p && /\.css$/.test(p.main)) {
          files.push(join(p.dest, p.main));
        }
      }
    });
  return files.filter(function(item, index, arr) {
    return index === arr.indexOf(item);
  });
}

function getSelf(file, pkg) {
  var files = [], deps = pkg.dependencies;
  pkg.files[file].dependencies
    .forEach(function(name) {
      if (name.charAt(0) !== '.') {
        var p = deps[name];
        if (p && /\.css$/.test(p.main)) {
          files.push(join(p.dest, p.main));
        }
      }
    });
  return files.filter(function(item, index, arr) {
    return index === arr.indexOf(item);
  });
}

function resolve(file, pkg) {
  file = extname(file) ? file : file + '.js';
  return join(pkg.dest, file);
}

function updateOptions(options) {
  options || (options = {});
  if (!options.pkg) throw new Error('missing pkg');
  options.include = options.include || 'relative';
  options.cwd = options.cwd || process.cwd();
  options.base = options.base || options.cwd;
  return options;
}
